
<!DOCTYPE html>
<meta charset="utf-8">
<body>


  <select id="dropdown"></select>

 

  
<script src="https://d3js.org/d3.v3.js"></script>
<!-- <script src="csvSUM.js"></script> -->
<!-- <script src="untitled.js"></script> -->
<script>

d3.csv("https://raw.githubusercontent.com/svparmar/summative/master/sum1/testtt.csv",function(data) {



const selector = document.getElementById("dropdown");


var yeargases2;
//all 7 gas colours + total at the end


  var headerNames = d3.keys(data[0]);
  var check = headerNames[0];


 var col2data = data.map(function(d) { return d[check] });

console.log('headerNames'); 
console.log(headerNames); 
  
console.log('specific year'); 
  console.log(check); // outputs: ['aaa2', 'bbb2', 'ccc2']

  console.log('col222'); 
  console.log(col2data);


//taken from
//https://www.d3-graph-gallery.com/graph/line_select.html
d3.select("#dropdown")
    .selectAll('myOptions')
    .data(headerNames)
        .enter()
        .append('option')
        .text(function (d) { return d; }) 
        .attr("value", function (dropdowndata) { return dropdowndata; })
        

//from https://codepen.io/tarsusi/pen/reovOV
d3.select("#dropdown").on("change",function(d){

          var dropdowndatainput = d3.select(this).property('value');

        console.log(dropdowndatainput);

       //createdataballs(dropdowndatainput);
      
          });


function createdataballs(yeardata){


  console.log('running yeardata');
  console.log(yeardata);

  //var yeargases = (data.map(function(d) { return d[yeardata] }));
 // console.log('yeargases');
 // console.log(yeargases);
  var yeargases = (data.map(function(d) { return d[yeardata] }));
 console.log('yeargases');
 //console.log(parseInt(yeargases));
 // yeargases2.yeargases = yeargases;

 // console.log('globallist HERE 1');
  //console.log(this.globallist);
  
  console.log('running for loop');
  for (i = 0; i < yeargases.length; i++) {
    
      console.log(yeargases[i]);


      yeargases[i] = parseInt(yeargases[i]);
     // switchRadius(circleradius)

    //  let trial = new makeCircles(yeardata,yeargases[i],colorssep[i]);
      //console.log(trial);
      //trial.makeThing();
}

  //console.log('trying to run list from createdataballs');
  //var nodes = [{radius: yeargases[1]}, {radius: yeargases[2]}, {radius: yeargases[3]}, {radius: yeargases[4]}, {radius: yeargases[5]}, {radius: yeargases[6]}, {radius: yeargases[7]}] ;


  //return{globallist:yeargases};

  //runSVG();
//var nodes = d3.range(9).map(function(d) { return {radius: d*10}; });
 // var teast=[10,20,30,40,50,60,70,80];
//  console.log(teast)


// console.log('yeargases');
// console.log(yeargases);

// console.log('testing');

// var testing = d3.scale.ordinal().range((yeargases));
// svg.selectAll("circle")
// console.log('here')

//     .data(nodes.slice(1))


//   .enter().append("circle")

//    .attr("r",function(d) { 
//     console.log('console.log(testing(d.index));');
//     console.log(testing(d.index));
//     return testing(d.index); })

//     .attr("fill", function(d) { return color(d.index);  });
 

//}
}



  function reassignment(){

    console.log('running reassignment');
 // console.log('yeargases2 HERE 2');
  //console.log(yeargases2);


  }
  //let list1  = new help(yeargases);
  //list1.setNode();

 // console.log('list1');
 // console.log(list1);







class help{

  
  constructor(list){
    this.list = list;
    //this.radius
  }

  
  setNode(){
    //
    list = this.list;
    console.log('RUNNING HELP sET');
    console.log(this.list)
    
  
  }
  getValue(){

    console.log('RUNNING HELP GET');
    //this.list = list;
    console.log(this.list)
    return this.list;
  }

}

//var list2= new help(list2);

//list2.getValue();
reassignment();



//SVG NOT MINE BELOW  //SVG NOT MINE BELOW  //SVG NOT MINE BELOW  //SVG NOT MINE BELOW


var width = 1060,
    height = 720;




  var nodes = d3.range(9).map(function(d) { return {radius: d*12}; });

//var nodes = procedure();


// var nodes = 
//     d3.range(9).map(function(d) { 

//       for (i = 0; i < d.length; i++) {

//         console.log(i);
        
// }

// return {radius: d*5 }; 

//     });


    console.log('nodes');
 //   console.log(nodes);

//var nodes = [{radius: 10}, {radius: 20}, {radius: 30}, {radius: 40}, {radius: 50}, {radius: 60}, {radius: 70}, {radius: 80}];

var root = nodes[0];
    

//var colors = ["#DCDCDC","#C0C0C0","#989898","#787878","#606060","#404040","#282828","#080808"];
var colors = ['#F0F0F0',"#DCDCDC",'#c8c8c8', '#707070',"#989898","#606060","#303030","#000000"];
var color = d3.scale.ordinal()
  .range(colors);





root.radius = 0;
root.fixed = true;

var force = d3.layout.force()
    .gravity(0.05)
    .charge(function(d, i) { return i ? 0 : -2000; })
    .nodes(nodes)
    .size([width, height]);

force.start();




var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);


runSVG();


function runSVG(){


d3.select("#dropdown").on("change",function(d){

          var yeardata = d3.select(this).property('value');

        console.log('yeardataaaaa');
        console.log(yeardata);

     //  createdataballs(dropdowndatainput);
      
         


  var yeargases = (data.map(function(d) { return d[yeardata] }));
 console.log('yeargases');
 //console.log(parseInt(yeargases));
 // yeargases2.yeargases = yeargases;

 // console.log('globallist HERE 1');
  //console.log(this.globallist);
  
  console.log('running for loop');
  for (i = 0; i < yeargases.length; i++) {
    
      console.log(yeargases[i]);


      yeargases[i] = parseInt(yeargases[i]);
     // switchRadius(circleradius)

    //  let trial = new makeCircles(yeardata,yeargases[i],colorssep[i]);
      //console.log(trial);
      //trial.makeThing();
}


var teast2 = yeargases;
 console.log('teast2')
  console.log(teast2)

var teast=[596.3, 132.5, 48.2, 14.4, 1.7, 1.3, 0, 794.4];
  console.log(teast)

var testing = d3.scale.ordinal()
  .range(teast2);

svg.selectAll("circle")
    .data(nodes.slice(1))


  .enter().append("circle")

  // .attr("r", function(d) { console.log('RUNNING attr');console.log(d);return d.radius; })

  // .attr("r",teast[1])
   //.attr("r",teast[2])
   //.attr("r",teast[3])

   .attr("r",function(d) { 
    console.log(testing(d.index))
    return testing(d.index)/4+10; })

    .attr("fill", function(d) {
      return color(d.index);  });

 




// console.log('yeargases');
// console.log(yeargases);

// console.log('testing');

// var testing = d3.scale.ordinal().range((yeargases));
// svg.selectAll("circle")
// console.log('here')

//     .data(nodes.slice(1))


//   .enter().append("circle")

//    .attr("r",function(d) { 
//     console.log('console.log(testing(d.index));');
//     console.log(testing(d.index));
//     return testing(d.index); })

//     .attr("fill", function(d) { return color(d.index);  });








  

//   var teast=[10,20,30,40,50,60,70,80];
//   console.log(teast)

// var testing = d3.scale.ordinal()
//   .range(teast);

// svg.selectAll("circle")
//     .data(nodes.slice(1))


//   .enter().append("circle")

//   // .attr("r", function(d) { console.log('RUNNING attr');console.log(d);return d.radius; })

//   // .attr("r",teast[1])
//    //.attr("r",teast[2])
//    //.attr("r",teast[3])

//    .attr("r",function(d) { 
//     return testing(d.index); })

//     .attr("fill", function(d) {
//       return color(d.index);  });
  //
//.attr("r", function() { return this.radius; })
    //.attr("r", function(yeargasesretrieval) { return yeargasesretrieval.radius; })
    //.style("fill", function(d, i) { return color(i % 3); });
   // .attr("fill", function(d) { return color('#D9D9D9FF');  });
  // .attr("r", data.map(function(d) { return size(d.yeargases); })

   //.attr("r",(data.map(function(d) { return {radius:d[yeargases] };})))
    });
}

class makeCircles{

  constructor(year,gas,colourball){

    this.year = year;
    this.gas = gas;
    this.radius = gas;

    this.colourball = colourball;

    console.log('RUNNING CLASS makeCircles');
    console.log(this.radius);
  }

  makeThing(){


  // d3.select("svg")
  // .selectAll("nodes")
  // .data(this.gas)
  // .enter()
  // .append('nodes')
  // .attr("r", this.radius)
  // .attr("fill", function(d) { return color(d.index);  });

    console.log('nodes');
    console.log(nodes);
    

    console.log(this.radius);
    console.log(this.radius);
  
  }
}




// function switchRadius(newRadius) {
    
//     console.log('running switchRadius');
//     console.log(newRadius);
//      return function() {
//        d3.selectAll('circle')
//           //.filter(function(d,i) { return i === 5; })
//           //.transition().duration(1000)
//           .tween('radius', function(d) {
//             var that = d3.select(this);
//             console.log('that');
//             console.log(that);
//             var i = d3.interpolate(d.radius, newRadius);

//             return function(t) {
//               d.radius = i(t);
//               that.attr('r', function(d) { return d.radius; });
//               force.nodes(data)
//             }
//           });
//        force.alpha(1).restart();
//      }
//      //runSVG();
//    }


      function switchRadius(newRadius) {
        
  //       d3.select("svg")
  // .selectAll("circle")
  // .data(newRadius)
  // .enter()
  // .append('circle')
  // .attr("r", function(d) { return 5*(d); })
 // .attr("height", function(d) { return 300; })
 // .attr("x",function(d,i) {return (i+1)*100;})
 // .attr("y",function(y) {return 40;});
   }




force.on("tick", function(e) {
  var q = d3.geom.quadtree(nodes),
      i = 0,
      n = nodes.length;

  while (++i < n) q.visit(collide(nodes[i]));

  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

svg.on("mousemove", function() {
  var p1 = d3.mouse(this);
  root.px = p1[0];
  root.py = p1[1];
  force.resume();
});

function collide(node) {
  var r = node.radius + 16,
      nx1 = node.x - r,
      nx2 = node.x + r,
      ny1 = node.y - r,
      ny2 = node.y + r;
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        l = (l - r) / l * .5;
        node.x -= x *= l;
        node.y -= y *= l;
        quad.point.x += x;
        quad.point.y += y;
      }
    }
    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
  };
}

});

</script>